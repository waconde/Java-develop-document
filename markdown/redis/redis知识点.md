## Redis 持久化机制：RDB 和 AOF
### RDB Redis DataBase
在指定时间间隔内，将内存中的数据集快照写入磁盘。会复制出一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。  
优势：
1. 整个 Redis 数据库会只包含一个 dump.rdb 文件，方便持久化
2. 容灾性好，方便备份
3. 性能最大化。通过子进程来完成文件 IO 操作，主进程可以继续处理命令，而不是被阻塞
4. 相对于大数据集时，比 AOF 启动效率高

劣势：
1. 数据安全性低。在两次持久化之间发生宕机时，会丢失数据
2. 当数据集较大时，复制子进程完成写入文件操作会导致整个服务器短暂地（< 1s）停止服务
### AOF Append Only File
以日志的形式记录服务器所处理的每一步写、删操作，查操作不会记录。可以打开日志文件查看操作记录  
优势：
1. 数据安全性高。Redis 还提供了三种同步策略：每秒同步、每修改同步、不同步。不过每秒同步也可能会丢失一秒钟之内的数据
2. 通过 append 模式写文件，即使服务器宕机，也不会破坏已存在的内容，还可以通过 redis-check-aof 工具解决数据一致性问题
3. AOF 有 rewrite 模式，会定期对 AOF 文件进行重写，以压缩文件

劣势：
1. AOF 文件比 RDB 文件大，恢复速度慢。所以需要 rewrite
2. 数据集较大时，比 RDB 启动效率低
3. 运行效率也没有 RDB 高

AOF 文件会比 RDB 更新频率高，优先使用 AOF 还原数据。两种机制可以并存，如果两种机制都配了，优先加载 AOF。
### 触发方式
手动触发：
1. save 命令，使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以在生产环境一定要慎用
2. bgsave 命令, fork 出一个子进程执行持久化，主进程只在 fork 过程中有短暂的阻塞，子进程创建之后，主进程就可以响应客户端请求了

自动触发：
1. save m n：在 m 秒内，如果有 n 个键发生改变，则自动触发持久化，通过 bgsave 执行，如果设置多个，只要满足其一就会触发，配置文件有默认配置(可以注释掉)
2. flushall：用于清空 redis 所有的数据库, flushdb 清空当前 redis 所在库数据(默认是 0 号数据库)，会清空 RDB 文件，同时也会生成 dump.rdb，内容为空
3. 主从同步：全量同步时会自动触发 bgsave 命令，生成 rdb 发送给从节点

## Redis AOF 同步策略
1. 每秒同步：异步完成，效率非常高，一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失
2. 每修改同步：同步持久化，每次发生的数据变化都会被立即记录到磁盘中，最多丢一条
3. 不同步：由操作系统控制，可能丢失较多数据

## Redis 过期键的删除策略（缓存过期）
Redis 是 key-value 数据库，可以设置 Redis 中缓存的 key 的过期时间。
1. 惰性过期：只有当访问一个 key 时，才会判断该 key 是否已过期，过期则清除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。
极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。
2. 定期过期：每隔一定的时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已过期的 key。
Redis 会同时使用这两种方案。

## 缓存淘汰算法
缓存大小有限，当要放入超过缓存大小的数据时，就需要淘汰一部分缓存数据来腾出空间。  
FIFO：先进先出。根据缓存被存储的时间，最早的数据将被淘汰  
LRU：最近最少使用。根据最近被使用的时间中，最少使用到的数据将被淘汰  
LFU：最不经常使用。在一段时间内，最少使用到的数据将被淘汰。

## 缓存穿透、缓存击穿、缓存雪崩
缓存雪崩：缓存中某一时刻大批热点数据同时过期，则可能导致大量请求直接访问 MySQL。  
解决办法：在过期时间上增加一点随机值，使得各个 Key 的过期时间不在同一时刻。  

缓存击穿：缓存中某一个热点 Key 突然过期，也可能导致大量请求直接访问 MySQL。  
解决办法：考虑该 Key 不设过期时间，或者不断刷新它的过期时间。  

缓存穿透：某一时刻访问缓存的大量 Key 都不在缓存中（比如伪造了大量的 Key 进行攻击），缓存就好像失效了一样，大量请求直接访问 MySQL。  
解决办法：在缓存之前加一层布隆过滤器，当它判定 Key 不存在时，那肯定不存在，直接返回。

## Redis 集群方案
### 哨兵 sentinel + 主从模式
哨兵是 redis 集群中非常重要的一个组件，主要有以下功能：  
集群监控：负责监控 redis master 和 slave 进程是否正常工作。  
消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。  
故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。  
配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。  
哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。
故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举。
即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的。
哨兵通常需要 3 个实例，来保证自己的健壮性。哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。
对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境都进行充足的测试和演练。  
但哨兵集群存在单点问题。
### Redis Cluster 模式
Redis Cluster 是一种服务端分片（Sharding）技术, 3.0 版本开始正式提供。
采用 slot 槽的概念，一共分成 16384 个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行  
方案说明：  
通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据。默认分配了 16384 个槽位。  
每份数据分片会存储在多个互为主从的多节点上  
数据写入先写主节点，再同步到从节点(支持配置为阻塞同步）  
同一分片多个节点间的数据不保持强一致性  
读取数据时，当客户端操作的 key 没有分配在该节点上时, redis 会返回转向指令，指向正确的节点，扩容时需要需要把旧节点的数据迁移一部分到新节点  
在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是加 1w 的端口号，比如 16379。  
16379 端口号是用来进行节点间通信的，也就是 cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。  
cluster bus 用了另外一种二进制的协议, gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和外理时间。

优点：
1. 无中心架构，支持动态扩容，对业务透明
2. 具备 Sentinel 的监控和自动 Failover (故障转移)能力
3. 客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可
4. 高性能，客户端直连 redis 服务，免去了 proxy 代理的损耗

缺点：
1. 运维也很复杂，数据迁移需要人工干预
2. 只能使用 0 号数据库
3. 不支持批量操作(pipeline 管道操作)
4. 分布式逻辑和存储模块耦合等
### Redis Sharding 模式
Redis Sharding 是 Redis Cluster 出来之前，业界普遍使用的多 Redis 实例集群方法。是一种客户端分片技术。  
其主要思想是采用哈希算法将 Redis 数据的 key 进行散列。通过 hash 函数，特定的 key 会映射到特定的 Redis 节点上。  
Java redis 客户端驱动 jedis，支持 Redis Sharding 功能，即 ShardedJedis 以及结合缓存池的 ShardedJedisPool。  

优点：  
非常简单，服务端的 Redis 实例彼此独立，相互无关联，每个 Redis 实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强

缺点：  
由于 sharding 处理放到客户端，规模进一步扩大时给运维带来挑战。  
客户端 sharding 不支持动态增删节点。服务端 Redis 实例群拓扑结构有变化时，每个客户端都需要更新调整。  
连接不能共享，当应用规模增大时，资源浪费制约优化。

## Redis 主从复制核心原理
通过执行 slaveof 命令或设置 slaveof 选项，让一个服务器去复制另一个服务器的数据。  
主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。  
而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。

全量复制步骤：
1. 主节点通过 bgsave 命令 fork 子进程进行 RDB 持久化，该过程是非常消耗 CPU、内存(页表复制)、硬盘 IO 的
2. 主节点通过网络将 RDB 文件发送给从节点，对主从节点的带宽都会带来很大的消耗
3. 从节点清空老数据、载入新 RDB 文件的过程是阻塞的，无法响应客户端的命令。如果从节点执行 bgrewriteaof，也会带来额外的消耗

部分复制步骤：
1. 复制偏移量：执行复制的双方，即主从节点，分别会维护一个复制偏移量 offset（以主节点 offset 为准）
2. 复制积压缓冲区：主节点内部维护了一个固定长度的、先进先出 FIFO 队列作为复制积压缓冲区。
当主从节点 offset 的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制
3. 复制服务器运行 ID(runid)：每个 Redis 节点，都有其运行 ID。运行 ID 由节点在启动时自动生成。
主节点会将自己的运行 ID 发送给从节点，从节点会将主节点的运行 ID 存起来。
从节点断开重连的时候，就是根据运行 ID 来判断同步的进度:
   1. 如果从节点保存的 runid 与主节点现在的 runid 相同，说明主从节点之前同步过。
   主节点会继续尝试使用部分复制(到底能不能部分复制还要看 offset 和复制积压缓冲区的情况)
   2. 如果从节点保存的 runid 与主节点现在的 runid 不同，说明从节点在断线前同步的 Redis 节点并不是当前的主节点，只能进行全量复制。

## Redis 一些问题
### 为什么说 Redis 是单线程的？
Redis 当然不是单线程，它也会有许多后台线程。之所以说它是单线程，是指：  
Redis 基于 Reactor 模式开发了网络事件处理器、文件事件处理器 file event handler，它是单线程的，所以 Redis 才叫做单线程的模型。  
它采用 IO 多路复用机制来同时监听多个 Socket，根据 Socket 上的事件类型来选择对应的事件处理器来处理这个事件。  
可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了 Redis 内部的线程模型的简单性。  
### Redis IO 多路复用机制？
Redis 文件事件处理器的结构包含 4 个部分：多个 Socket、IO 多路复用程序、文件事件分派器以及事件处理器(命令请求处理器、命令回复处理器、连接应答处理器等)。  
多个 Socket 可能并发的产生不同的事件, IO 多路复用程序会监听多个 Socket。会将 Socket 放入一个队列中排队。  
每次从队列中有序、同步取出一个 Socket 给事件分派器，事件分派器把 Socket 给对应的事件处理器。  
然后一个 Socket 的事件处理完之后, IO 多路复用程序才会将队列中的下一个 Socket 给事件分派器。  
文件事件分派器会根据每个 Socket 当前产生的事件来选择对应的事件处理器来处理。
### Redis 是单线程的，为什么性能可以那么高？
1. 纯内存操作：Redis 是基于内存操作的，没有和磁盘的 IO 交互。所以每个请求处理都很快
2. 核心是基于非阻塞的 IO 多路复用机制
3. 没有进程上下文切换的性能损耗：多线程在进程切换时会有切换进程上下文的损耗。JAVA 需要多线程是因为许多进程都涉及到许多阻塞场景，如等待 IO。
此时切换其他进程来执行反而能充分利用 CPU 资源。而 Redis 没有阻塞的情况，因此要避免进程切换提高性能。
### Redis 和 Mysql 如何保证数据一致？
方案1. 先更新 Mysql，再更新 Redis，如果更新 Redis 失败，可能仍然不一致  
方案2. 先删除 Redis 缓存数据，再更新 Mysql，再次查询的时候在将数据添加到缓存中。  
这种方案能解决 1 方案的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题。
比如线程 1 删除了 Redis 缓存数据，正在更新 Mysql，此时另外一个查询再查询，那么就会把 Mysql 中老数据又查到 Redis中。  
方案3. 延时双删：先删除 Redis 缓存数据，再更新 Mysql，延迟几百毫秒再删除 Redis 缓存数据。  
这样就算在更新 Mysql时，有其他线程读了 Mysql，把老数据读到了 Redis 中，那么也会被删除掉，从而把数据保持一致。
### 简述 Redis 分布式锁的实现？
低版本：setnx, setpx
高版本：set(key, value, nx, px)
